is interesting use the flag `-g3` in the `gcc` or `clang` compiler to get all debug information in compiled processes

```bash
cc main.c -g3 -Wall -Wextra -Werror -fsanitize=address -o main
```

when we had a error the output in `running time`[[Compiling Processes]] is gonna be something like this:
![[Pasted image 20240922225941.png]]

The came from the previous code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define SENT_LEN 19

int main(void)
{
char sentece[] = "This is a sentence.";
char mem[SENT_LEN];
strcpy(mem, sentece);
printf("format %s is the resulting string. \n", mem);
return EXIT_SUCCESS;
}
```

---
#### Starting with the red part

```bash
==31989==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7dc903009033 at pc 0x7dc9054a6c23 bp 0x7ffe7792acc0 sp 0x7ffe7792a468
```

- This error tell to us that we had a `stack-buffer-overflow` that's indicates that we are trying to access an area of ​​memory outside the bounds of a stack-allocated buffer

- In the address `0x7dc903009033` is the exactly point of memory the buffer overflow happens, this area is outside the boundaries of us stack

- `pc 0x7dc9054a6c23`, the "pc" came from ==program counter== that show the address in the **code** where the problem happen, is important to know the area in the code we wrong.

- `bp 0x7ffe7792acc0`, the "bp" came from ==base pointer== is a pointer to the bottom of stack, points to the beginning of the current function stack frame.

- `sp 0x7ffe7792a468` the "sp" came from ==stack pointer== is the current address of stack, normally point the top of stack and changes as the data is stacked and unstacked. (recommend see [[Stack & Heap]])

---

#### Operation, position and address
```bash
WRITE of size 20 at 0x7dc903009033 thread T0
```
This indicates the memory location where the error occurred and the operation we attempted to perform. The same address, `0x7dc903009033`, is displayed in the first section

---
#### Report list (optional)
```bash
#0 0x73bc3e6a6c22 in strcpy  ../../../../src/libsanitizer/asan/asan_interceptors.cpp:563
#1 0x58e37c6bc39a in main /home/ubuluc/42SP_Libft/watchVideo.c:10
#2 0x73bc3e22a1c9 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #3 0x73bc3e22a28a in __libc_start_main_impl ../csu/libc-start.c:360
    #4 0x58e37c6bc184 in _start (/home/ubuluc/42SP_Libft/main+0x1184) (BuildId: 910f81c728b5887ecd54f6555bccfe6a3d14dcbf)
```

Basically, what we see after "operation, position and address" is what we call a ==Back Trace==. which is a visual representation of the calls in our program the `stack frame`.

In a hierarchical manner, we start with `#4`, which is `_start`. In 

Summary, `_start` is an initialization function that is automatically generated by the linker and is responsible for setting up the program environment before execution. It arranges libraries and configures environment variables.

`__libc_start_main_impl` is called by the `_start` function and, in summary, initializes allocation libraries and argument handling (argc & argv), in addition to managing the output of the main function.

`__libc_start_call_main` is responsible for effectively calling the main function after all the initial setup, as well as handling errors from main and ensuring the proper termination of the program.

It's worth noting that before this call, the code has already been the [[Book - compiling processes]], meaning we have a binary to read.

---

#### Thread 

Is interesting to notice the concept of `thread` and `stack` basically the threads are processing unit that executes each `frame stack`. frequently we see ==t0== that's the main thread. [[CPU,Core & Threads]]

```bash
Address 0x7dc903009033 is located in stack of thread T0 at offset 51 in frame
    #0 0x58e37c6bc258 in main /home/ubuluc/42SP_Libft/watchVideo.c:6
```

again it gives us the exact address where the error `0x7dc903009033` occurred, it tells us in which thread the error occurred, in this case it was the main thread `T0`

As the ==stack frame== grows inversely, that is, the smaller the address, the larger the stack, the offset means how many bytes down the stack frame was

`/watchVideo.c:6` in the final it shows the line that's our frame

---

#### Objects in a stack frame

```bash
his frame has 2 object(s):
    [32, 51) 'mem' (line 8) <== Memory access at offset 51 overflows this variable
    [96, 116) 'sentece' (line 7)
```

basicamente essa secção informa para gente quais são as variaiveis e objetos que temos em nossa stack frame, e o seus `offset`em relação o `base pointer(bp)` daquela stack frame [32, 51]. além de seu nome `mem` ou `sentence`. 

---
#### Shadow bytes

Agora temos a representação dos bytes em mémoria para termos uma noção melhor de onde o erro ocorreu

![[Pasted image 20240923212012.png]]

é importante ressaltar que o shadow bytes em alguns casos podem ter seus valores bem distantes do que os mostrados em `bp` `sp`, pois em alguns programas mostram o shadow byte de onde o sanitizer executou nosso código para debugar.

each `00` represent `8 bits = 1 byte`, each line represent `16 bytes = 128 bits`

---
#### Dictionary 
- pc = program counter
- bp = base pointer
- sp = stack pointer

- Back trace | stack trace = is a representation of the program's call stack at a given point of execution, usually at the time when an error or exception occurred.

- Offset  = refers to the distance in bytes of memory address from a reference point. in almost case in this section refers to the initial stack frame 

- Little Endian | Big Endian = order of store bits





